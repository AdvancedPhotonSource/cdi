// GENERAL
save_dir = "results_dir"
                             // directory where vtk files are saved, and the data and raw results if configured

action = "new_guess"
                             // action defines what is processed by the program:
                             // if "prep_only" the program will only do the data preparation and save in the save_dir
                             // if "new_guess" the program will do the data prepation and will start reconstruction
                             // starting with random guess
                             // if "continue" the program jumps right to the reconstruction starting with saved data,
                             // raw reconstructed image, and support. With this action a continue_dir must be defined
                             // that contains the saved files. If only data is saved the program will start a new guess.

continue_dir = "AB_dir"
                             // a directory containing prepared data and results of previous reconstruction.
                             // if action is "continue", the reconstruction will start with these results.

save_results = true
                             // if save_results is true, the prepared data, raw image and support will be saved in
                             // the save_dir


// PARAMETER FOR DATA PREPARATION
amp_threshold = 2.0
                             // min data threshold.  Values below this are set to 0. The threshold is applied
                             // set before removing aliens and binning.

aliens = ((170,220,112,195,245,123), (50,96,10,60,110,20))
                             // comment out aliens for no removal, otherwise input them as
                             // aliens=[[x0,y0,z0,x1,y1,z1],[x2,y2,z2,x3,y3,z3]]
                             // will remove two instances of aliens given by the pairs
                             // #0 and #1 and another given by #2,#3. accepts as
                             // many as you like.

binning = [2,2,2]
                             // applied after aliens

center_shift = [0,0,0]
                             // the maximum is centered after binning, and moved according to center_shift

adjust_dimensions = [0, 3, -5]
                             // applied after centering. If number is positive, the array will be padded
                             // with 0s in this dimension by the pad number on each end.
                             // If negative, the array will be cropped by that number on each end in this
                             // dimension.
                             // The final dimensions will adjusted up to the opencl supported dimensions
                             // i.e. divisible by 2, 3, and 5 only


// RECONSTRUCTION PARAMETERS USED BY FAST MODULE
gc = 5;
                             // ArrayFire memory management is not reliable, the way around is to call garbage
                             // collection per defined number of iterations. Decrease this value if out of memory
                             // error occurs

//algorithm_sequence = ((3, ("ER",2), ("HIO", 2), ("ER", 2)), (2, ("ER",3), ("HIO",3)))
//algorithm_sequence = ((1, ("ER",6)))
algorithm_sequence = ((1, ("ER",19), ("HIO", 10)), (1,("ER",10)))
//algorithm_sequence = ((1, ("ER",10), ("HIO", 20)), (1,("ER",10)))
//algorithm_sequence = ((1, ("ER",19), ("HIO", 10)), (1,("ER",10)), (1, ("ER",10), ("HIO", 20)), (1,("ER",10)))
                             // defines algorithm applied in each iteration by a sequence of tuples.
                             // The first number in a tuple is a repeat, followed by tuples of pairs, each
                             // pair defining algorithm and number of iterations to run the algorithm.

twin = 2;
//twin = -1
                             // twin defines at which iteration to cut half of the array(i.e. multiply by 0s),
                             // it is done in ER/HIO. If don't want to apply twin, set it negative.


//amp_threshold_fill_zeros = true;
//phase_min = -2.0;
//phase_max = 2.0;
//beta = .9;

// support
//support_triggers = ((5, 5, 300), (1, 2));
support_triggers = ((4, 5, 300));
//support_triggers = ((1, 5, 300));
                             // trigger contains starting iteration, step, and ending iteration (if missing, run
                             // to the end).
support_type = "GAUSS";
support_threshold = 0.1;
support_sigma = 1;
support_area = [.5,.5,.5];
                             // initial support area. If the values are fractional, the support area will be calculated
                             // by multiplying by the data array dimensions. The support will be set to 1s to this
                             // dimensions centered.

// partial coherence
partial_coherence_type = "LUCY";
                             // if type is not defined, partial coherence is not applied
partial_coherence_triggers = ((14, 15));
//partial_coherence_triggers = ((1, 15));
                             // trigger contains starting iteration, step, and ending iteration (if missing, run
                             // to the end).
partial_coherence_iteration_num = 20;
partial_coherence_normalize = true;
partial_coherence_roi = [32,32,32];
                             // coherence area. If the values are fractional, the coherence area will be calculated
                             // by multiplying by the data array dimensions.

regularized_amp = "GAUSS";

avg_iterations = 15;
                             // number of last iterations that the image amplitudes will be included to calculate
                             // final

// PARAMETERS FOR VISUALISATION
// wavelength
lamda = .13933;
// delta (degrees)
delta = 30.1;
// gamma (degrees)
gamma = 14.0;
// camera distance (m)
arm=0.6350;
// angular step size
dth=0.000174532925199;

// detector pixel sixe
pixel = [55.0e-6, 55.0e-6];

// size to crop the image array
//crop = [120,120,120]
crop = [.85, .85, .85]

