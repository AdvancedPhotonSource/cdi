// GENERAL
save_dir = "results_dir"
                             // directory where vtk files are saved, and the data and raw results if configured

action = "new_guess"
                             // action defines what is processed by the program:
                             // if "prep_only" the program will only do the data preparation and save in the save_dir
                             // if "new_guess" the program will do the data prepation and will start reconstruction
                             // starting with random guess
                             // if "continue" the program jumps right to the reconstruction starting with saved data,
                             // raw reconstructed image, and support. With this action a continue_dir must be defined
                             // that contains the saved files. If only data is saved the program will start a new guess.

continue_dir = "results_dir"
                             // a directory containing prepared data and results of previous reconstruction.
                             // if action is "continue", the reconstruction will start with these results.

save_results = true
                             // if save_results is true, the prepared data, raw image and support will be saved in
                             // the save_dir


// generations
generations = 1              // number of generations

low_resolution_generations = 0
                             // number of generations low resolution is applied to, starting from first gen

low_resolution_sigma_alg = "SIG_SPACE_LINEAR"
                             // defines how to calculate sigmas based on generation. Supported:
                             // SIG_SPACE_LINEAR - sigmas are starting from low_resolution_sigma_max,
                             // linearly decreasing for each generation, reaching low_resolution_sigma
                             // at the end
                             // SIG_SCALE_POWER - use low_resolution_scale_power and ScaleFactor
                             //                to calculate sigmas for generations
                             // SIG_ASSIGNED - sigmas will be read from low_resolution_sigmas

low_resolution_sigmas = [1.0]
                             // list of sigmas that will be used by subsequent generations if the 
                             // low_resolution_sigma_alg is set to SIG_ASSIGNED
                             // the length must be equal low_resolution_generations

low_resolution_sigma_min = 0.1
                             // initial sigma

low_resolution_sigma_max = 2.0
                             // max support sigma value

low_resolution_scale_power = 1
                             // how the sigma scales with generation (1 - linear, 2 - quad etc)

low_resolution_alg = "GAUSS"
                             // algorithm to use to apply resolution. Supported algorithms:
                             // GAUSS

// PARAMETER FOR DATA PREPARATION
amp_threshold = 2.0
                             // min data threshold.  Values below this are set to 0. The threshold is applied
                             // set before removing aliens and binning.

aliens = ((170,220,112,195,245,123), (50,96,10,60,110,20))
                             // comment out aliens for no removal, otherwise input them as
                             // aliens=[[x0,y0,z0,x1,y1,z1],[x2,y2,z2,x3,y3,z3]]
                             // will remove two instances of aliens given by the pairs
                             // #0 and #1 and another given by #2,#3. accepts as
                             // many as you like.

binning = [2,2,2]
                             // applied after aliens

center_shift = [0,0,0]
                             // the maximum is centered after binning, and moved according to center_shift

adjust_dimensions = [0, 3, -5]
                             // applied after centering. If number is positive, the array will be padded
                             // with 0s in this dimension by the pad number on each end.
                             // If negative, the array will be cropped by that number on each end in this
                             // dimension.
                             // The final dimensions will adjusted up to the opencl supported dimensions
                             // i.e. divisible by 2, 3, and 5 only


// RECONSTRUCTION PARAMETERS USED BY FAST MODULE
device = 0
                   // ID of the target device

gc = 5;
                             // ArrayFire memory management is not reliable, the way around is to call garbage
                             // collection per defined number of iterations. Decrease this value if out of memory
                             // error occurs

plot_errors = true           // indicates whether to plot errors during calculations. Plotting will slow down.

//algorithm_sequence = ((3, ("ER",2), ("HIO", 2), ("ER", 2)), (2, ("ER",3), ("HIO",3)))
//algorithm_sequence = ((1, ("ER",6)))
algorithm_sequence = ((1, ("ER",19), ("HIO", 10)), (1,("ER",20)))
//algorithm_sequence = ((1, ("ER",19), ("HIO", 4)), (1,("ER",4)))
//algorithm_sequence = ((1, ("ER",19), ("HIO", 10)), (1,("ER",10)), (1, ("ER",10), ("HIO", 20)), (1,("ER",10)))
                             // defines algorithm applied in each iteration by a sequence of tuples.
                             // The first number in a tuple is a repeat, followed by tuples of pairs, each
                             // pair defining algorithm and number of iterations to run the algorithm.

twin = 2;
//twin = -1
                             // twin defines at which iteration to cut half of the array(i.e. multiply by 0s),
                             // it is done in ER/HIO. If don't want to apply twin, set it negative.

//amp_threshold_fill_zeros = true;
phase_triggers = ((1, 1, 32))
phase_min = -2.0;
phase_max = 2.0;

beta = .9;

// support
//support_triggers = ((5, 5, 300), (1, 2));
support_triggers = ((5, 4, 300));
//support_triggers = ((1, 5, 300));
                             // trigger contains starting iteration, step, and ending iteration (if missing, run
                             // to the end).
support_type = "GAUSS";
support_threshold = 0.1;
support_sigma = 1.0;
support_area = [.5,.5,.5];
                             // initial support area. If the values are fractional, the support area will be calculated
                             // by multiplying by the data array dimensions. The support will be set to 1s to this
                             // dimensions centered.

// partial coherence
partial_coherence_type = "LUCY";
                             // if type is not defined, partial coherence is not applied
partial_coherence_triggers = ((5, 14));
                             // trigger contains starting iteration, step, and ending iteration (if missing, run
                             // to the end).
partial_coherence_iteration_num = 20;
partial_coherence_normalize = true;
partial_coherence_roi = [32,32,32];
                             // coherence area. If the values are fractional, the coherence area will be calculated
                             // by multiplying by the data array dimensions.

iter_low_res_sigma_min = 0.0
                             // used when applying low resolution data mask while iterating. The mask is 
                             // gauss with sigma from sigma max to sigma min.
                             // if iter_low_res_sigma_min is 0 or not defined, the value is assigned to support_sigma
iter_low_res_sigma_max = 3.0
                             // max sigma, if not defined, default to 3
update_resolution_triggers = (1, 20)
                             // the data is being modified with calculated mask starting with first iteration. 
                             // the trigger defines step and last iteration for which it is applied

regularized_amp = "GAUSS";

avg_iterations = 15;
                             // number of last iterations that the image amplitudes will be included to calculate
                             // final

// PARAMETERS FOR VISUALISATION
// wavelength
lamda = .13933;
// delta (degrees)
delta = 30.1;
// gamma (degrees)
gamma = 14.0;
// camera distance (m)
arm=0.6350;
// angular step size
dth=0.000174532925199;

// detector pixel sixe
pixel = [55.0e-6, 55.0e-6];

// size to crop the image array
//crop = [120,120,120]
crop = [.85, .85, .85]

